<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku Overlay — Align → Solve (Multi-select)</title>
  <style>
    :root { --bg:#0f1115; --panel:#171a21; --text:#e6e8ee; --muted:#9aa3b2; --accent:#4da3ff; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text);
      font: 15px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    .toolbar { position: fixed; inset: 12px 12px auto 12px; background: var(--panel);
      border: 1px solid #2a2f3a; border-radius: 14px; padding: 8px 10px; display: flex;
      gap: 10px; align-items: center; z-index: 3; box-shadow: 0 8px 24px rgba(0,0,0,.2); flex-wrap: wrap; }
    .btn { appearance: none; border: 1px solid #2a2f3a; background: #1c2130; color: var(--text);
      padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .btn:hover { border-color: #3a4252; }
    .file { position: relative; overflow: hidden; }
    .file input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
    .status { color: var(--muted); font-size: 13px; margin-left: 4px; }
    .row { display: inline-flex; gap: 10px; align-items: center; }
    .range { display: inline-flex; align-items: center; gap: 8px; color: var(--muted); font-size: 13px; }
    input[type="range"] { width: 120px; }
    .pill { padding: 4px 8px; border-radius: 999px; background:#111521; border:1px solid #2a2f3a; color:var(--muted); font-size:12px; }

    .stage-wrap { position: fixed; inset: 0; display: grid; }
    canvas {
      display: block; background: #0b0d12;
      max-width: 1000px; max-height: 720px; width: 100%; height: auto; margin: auto;
    }

    .drop-hint { position: fixed; inset: 0; display: none; place-items: center; pointer-events: none; z-index: 2; }
    .drop-hint.show { display: grid; }
    .drop-card { border: 2px dashed var(--accent); border-radius: 16px; padding: 28px 32px;
      background: rgba(20, 90, 200, .12); color: var(--text); font-size: 18px; text-align: center; user-select: none; }
    .kbd { background: #111521; border: 1px solid #2a2f3a; padding: 2px 6px; border-radius: 6px; font-size: .9em; }

    /* keypad */
    #keypad { display:none; gap:6px; }
    #keypad .btn { padding: 6px 10px; }
  </style>
</head>
<body>
  <div class="toolbar">
    <label class="btn file" for="fileInput">Upload image</label>
    <input id="fileInput" type="file" accept="image/*" hidden />

    <div class="row">
      <button id="confirmBtn" class="btn">Confirm Grid</button>
      <button id="clearAllBtn" class="btn" title="Clear all digits & hints">Clear All</button>
      <span class="pill" id="gridTip">Align mode: drag to move • □ to scale</span>
      <div id="keypad">
        <button class="btn" data-n="1">1</button><button class="btn" data-n="2">2</button>
        <button class="btn" data-n="3">3</button><button class="btn" data-n="4">4</button>
        <button class="btn" data-n="5">5</button><button class="btn" data-n="6">6</button>
        <button class="btn" data-n="7">7</button><button class="btn" data-n="8">8</button>
        <button class="btn" data-n="9">9</button>
        <button class="btn" data-n="0" title="Clear cell">⌫</button>
      </div>
      <button id="saveBtn" class="btn" title="Save canvas as PNG (⌘/Ctrl+S)">Save Result as Image</button>
    </div>

    <span class="status" id="status">Drop an image anywhere or use Upload.</span>
  </div>

  <div class="stage-wrap">
    <canvas id="stage" aria-label="Sudoku image canvas"></canvas>
  </div>

  <div class="drop-hint" id="dropHint" aria-hidden="true">
    <div class="drop-card">Drop your Sudoku screenshot here<br/><small>(or press <span class="kbd">U</span> to open file picker)</small></div>
  </div>

  <script>
    // ---------------- State ----------------
    const makeHintGrid = () => Array.from({length:9}, () => Array.from({length:9}, () => new Set()));
    const state = {
      img: null, imgNaturalW: 0, imgNaturalH: 0,
      mode: 'align', // 'align' | 'solve'
      grid: { x: 0, y: 0, s: 1, cell: 50, opacity: 0.8, _initialized: false },
      drag: null, // {mode:'move'|'scale', gx,gy, s0, dist0}
      // selection drag (solve mode)
      selDrag: null, // { anchor:{r,c}, last:{r,c} }
      board: {
        x: 0, y: 0, cell: 0,
        values: Array.from({length:9}, () => Array(9).fill(0)),
        hints: {
          center: makeHintGrid(),
          top:    makeHintGrid(),
          bottom: makeHintGrid(),
        },
        selection: new Set(),
        anchor: { r:-1, c:-1 }
      },
      paintDrag: null, // { adding: true|false, lastKey: "r,c" }
    };

    // --------------- Elements --------------
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const fileInput = document.getElementById('fileInput');
    const dropHint = document.getElementById('dropHint');
    const confirmBtn = document.getElementById('confirmBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const gridTip = document.getElementById('gridTip');
    const keypad = document.getElementById('keypad');
    const saveBtn = document.getElementById('saveBtn');

    // --------------- Helpers ---------------
    let _picking = false;
    function openFilePicker() {
      if (_picking) return;
      _picking = true;

      // When the dialog closes (picked or canceled), window regains focus.
      const reset = () => {
        _picking = false;
        window.removeEventListener('focus', reset);
        fileInput.removeEventListener('change', reset);
      };

      window.addEventListener('focus', reset, { once: true });
      fileInput.addEventListener('change', reset, { once: true });

      fileInput.click();
    }

    const setStatus = (msg) => statusEl.textContent = msg;

    function resizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth | 0;
      const cssH = canvas.clientHeight | 0;
      const need = canvas.width !== Math.round(cssW * dpr) || canvas.height !== Math.round(cssH * dpr);
      if (need) {
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      return need;
    }

    function fitImageRect(imgW, imgH, viewW, viewH) {
      const scale = Math.min(viewW / imgW, viewH / imgH);
      const w = Math.max(1, Math.floor(imgW * scale));
      const h = Math.max(1, Math.floor(imgH * scale));
      const x = Math.floor((viewW - w) / 2);
      const y = Math.floor((viewH - h) / 2);
      return { x, y, w, h };
    }

    function clearCanvas() { ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.restore(); }

    function commitHint(pos, d) { // pos: 'center' | 'top' | 'bottom'
      if (state.mode !== 'solve' || !anySelected()) return;
      pushHistory();
      const grid = state.board.hints[pos];
      for (const k of state.board.selection) {
        const [r, c] = k.split(',').map(Number);
        if (state.board.values[r][c] !== 0) continue; // don't hint over final digits
        const set = grid[r][c];
        set.has(d) ? set.delete(d) : set.add(d);
      }
      redraw();
    }

    function clearHints(pos) {
      if (!anySelected()) return;
      pushHistory();
      const grid = state.board.hints[pos];
      for (const k of state.board.selection) {
        const [r,c] = k.split(',').map(Number);
        grid[r][c].clear();
      }
      saveToCache();
      redraw();
    }

    // ---- grid sizing helpers (no rotation) ----
    const gridPx = () => state.grid.cell * state.grid.s;      // one cell px
    const gridHalf = () => (gridPx() * 9) / 2;
    function pointInGrid(px, py) {
      const half = gridHalf();
      return Math.abs(px - state.grid.x) <= half && Math.abs(py - state.grid.y) <= half;
    }
    function scaleHandleRect() {
      const half = gridHalf();
      const size = Math.max(20, gridPx() * 0.35);
      const cx = state.grid.x + half, cy = state.grid.y + half;
      return { x: cx - size/2, y: cy - size/2, w: size, h: size };
    }
    function hitHandle(px, py) {
      const h = scaleHandleRect();
      return (px >= h.x && px <= h.x + h.w && py >= h.y && py <= h.y + h.h) ? 'scale' : null;
    }
    function gridRect() {
      const size = gridPx() * 9;
      const half = size / 2;
      return { x: state.grid.x - half, y: state.grid.y - half, w: size, h: size, cell: gridPx() };
    }

    // ---- board helpers ----
    function boardHit(px, py) {
      const { x, y, cell } = state.board;
      const r = Math.floor((py - y) / cell);
      const c = Math.floor((px - x) / cell);
      if (r >= 0 && r < 9 && c >= 0 && c < 9) return { r, c };
      return null;
    }

    // selection helpers
    const keyOf = (r,c) => `${r},${c}`;
    function clearSelection() { state.board.selection.clear(); }
    function addToSelection(r,c) { state.board.selection.add(keyOf(r,c)); }
    function toggleSelection(r,c) {
      const k = keyOf(r,c);
      if (state.board.selection.has(k)) state.board.selection.delete(k);
      else state.board.selection.add(k);
    }
    function selectRange(r1,c1,r2,c2) {
      clearSelection();
      const rr1 = Math.min(r1,r2), rr2 = Math.max(r1,r2);
      const cc1 = Math.min(c1,c2), cc2 = Math.max(c1,c2);
      for (let r=rr1; r<=rr2; r++) for (let c=cc1; c<=cc2; c++) addToSelection(r,c);
    }
    function anySelected() { return state.board.selection.size > 0; }
    function firstSelected() {
      for (const k of state.board.selection) {
        const [r,c] = k.split(',').map(Number);
        return {r,c};
      }
      return { r:-1, c:-1 };
    }

    // --------------- Drawing ----------------
    function drawGrid() {
      const { x, y, s, cell, opacity } = state.grid;
      const size = cell * 9 * s;
      const half = size / 2;

      ctx.save();
      ctx.globalAlpha = opacity;

      // faint backdrop
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(x - half, y - half, size, size);

      // lines
      ctx.lineCap = 'butt';
      for (let i = 0; i <= 9; i++) {
        ctx.beginPath();
        ctx.lineWidth = (i % 3 === 0) ? 2 : 1;
        ctx.strokeStyle = (i % 3 === 0) ? '#00e60f' : '#00e60f';
        const vx = x - half + i * gridPx();
        ctx.moveTo(vx, y - half);
        ctx.lineTo(vx, y + half);
        ctx.stroke();

        ctx.beginPath();
        ctx.lineWidth = (i % 3 === 0) ? 2 : 1;
        const hy = y - half + i * gridPx();
        ctx.moveTo(x - half, hy);
        ctx.lineTo(x + half, hy);
        ctx.stroke();
      }
      ctx.restore();

      // scale handle (square)
      const h = scaleHandleRect();
      ctx.save();
      ctx.fillStyle = '#111'; ctx.globalAlpha = 0.9;
      ctx.fillRect(h.x, h.y, h.w, h.h);
      ctx.lineWidth = 2; ctx.strokeStyle = '#4da3ff';
      ctx.strokeRect(h.x, h.y, h.w, h.h);
      ctx.restore();
    }

    function drawBoard() {
      const { x, y, cell, values } = state.board;

      // highlight all selected cells
      if (anySelected()) {
        ctx.save();
        ctx.fillStyle = 'rgba(77,163,255,0.25)';
        for (const k of state.board.selection) {
          const [r,c] = k.split(',').map(Number);
          ctx.fillRect(x + c*cell, y + r*cell, cell, cell);
        }
        ctx.restore();
      }

      // subtle 3x3 boxes to keep orientation
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0)'; // subtle, matches black digits vibe
      for (let br = 0; br < 3; br++) {
        for (let bc = 0; bc < 3; bc++) {
          ctx.strokeRect(x + bc*3*cell, y + br*3*cell, 3*cell, 3*cell);
        }
      }
      ctx.restore();

      // numbers (black)
      ctx.save();
      ctx.fillStyle = '#0542ab';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${Math.floor(cell * 0.75)}px system-ui, -apple-system, sans-serif`;
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const v = values[r][c];
          if (v) {
            const cx = x + c*cell + cell/2;
            const cy = y + r*cell + cell/2;
            ctx.fillText(String(v), cx, cy + 1);
          }
        }
      }
      ctx.restore();

      // Hints (half-size). We draw top, center, bottom if cell is empty.
      ctx.save();
      ctx.fillStyle = '#8aa2c0';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const smallerHintFontPx = Math.floor(state.board.cell * 0.275);
      ctx.font = `bold ${smallerHintFontPx}px system-ui, -apple-system, sans-serif`;

      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (values[r][c] !== 0) continue; // hide hints when a final digit exists
          const cx = x + c*cell + cell/2;

          // positions (tweak offsets if you like)
          const cyTop    = y + r*cell + cell*0.18;
          const cyCenter = y + r*cell + cell*0.50;
          const cyBottom = y + r*cell + cell*0.82;

          const drawSet = (set, cy) => {
            if (!set || set.size === 0) return;
            const text = Array.from(set).sort((a,b)=>a-b).join('');
            ctx.fillText(text, cx, cy);
          };

          drawSet(state.board.hints.top[r][c],    cyTop);
          drawSet(state.board.hints.center[r][c], cyCenter);
          drawSet(state.board.hints.bottom[r][c], cyBottom);
        }
      }
      ctx.restore();
    }

    function redraw() {
      resizeCanvasToDisplaySize();
      clearCanvas();

      if (!state.img) return;

      const rect = fitImageRect(state.imgNaturalW, state.imgNaturalH, canvas.clientWidth, canvas.clientHeight);
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(state.img, rect.x, rect.y, rect.w, rect.h);

      if (!state.grid._initialized) initGrid(rect);

      if (state.mode === 'align') drawGrid();
      else drawBoard();
    }

    // --------------- Image loading ----------
    async function handleFile(file) {
      if (!file) return;
      localStorage.removeItem('sudokuCache');
      localStorage.removeItem('sudokuImage');

      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result; // data URL
        localStorage.setItem('sudokuImage', base64);

        const img = new Image();
        img.onload = () => {
          state.img = img;
          state.imgNaturalW = img.naturalWidth;
          state.imgNaturalH = img.naturalHeight;
          state.grid._initialized = false;
          state.mode = 'align';
          state.board.selection = new Set();
          state.board.anchor = { r:-1, c:-1 };
          keypad.style.display = 'none';
          gridTip.style.display = '';
          setStatus(`${file.name} — ${img.naturalWidth}×${img.naturalHeight}`);
          redraw();
        };
        img.src = base64;
      };
      reader.readAsDataURL(file);
    }

    // --------------- Init grid --------------
    function initGrid(rect) {
      const g = state.grid;
      const target = Math.min(rect.w, rect.h) * 0.6; // 60% of shorter side
      const pxPerCell = target / 9;
      g.cell = Math.max(24, Math.floor(pxPerCell));
      g.s = 1;
      g.x = rect.x + rect.w / 2;
      g.y = rect.y + rect.h / 2;
      g._initialized = true;
    }

    // --------------- Input ------------------
    function getPos(e) {
      const t = (e.touches && e.touches[0]) || e;
      const rect = canvas.getBoundingClientRect();
      return { x: t.clientX - rect.left, y: t.clientY - rect.top };
    }

    function onDown(e) {
      if (!state.img) return;

      const { x, y } = getPos(e);

      if (state.mode === 'align') {
        const handle = hitHandle(x, y);
        if (handle === 'scale') {
          const dx = x - state.grid.x, dy = y - state.grid.y;
          const half0 = gridHalf(); // uses current s
          const tlx0 = state.grid.x - half0;
          const tly0 = state.grid.y - half0;
          state.drag = {
            mode: 'scale',
            tlx0, tly0 // anchor: fixed top-left during scaling
          };
        } else if (pointInGrid(x, y)) {
          state.drag = { mode: 'move', gx: state.grid.x - x, gy: state.grid.y - y };
        }
        if (state.drag) e.preventDefault();
        return;
      }

      // --- solve mode: paint selection ---
      const hit = boardHit(x, y);
      if (!hit) return;

      const k = keyOf(hit.r, hit.c);
      const modAdd = e.ctrlKey || e.metaKey || e.shiftKey; // treat any of these as "add mode"

      if (modAdd) {
        // Add the clicked cell and start an additive paint drag
        addToSelection(hit.r, hit.c);
        state.paintDrag = { adding: true, lastKey: k };
        redraw(); e.preventDefault(); return;
      }

      // No modifier: clicking the already-selected single cell clears selection (current behavior)
      if (state.board.selection.size === 1 && state.board.selection.has(k)) {
        clearSelection();
        state.board.anchor = { r:-1, c:-1 };
        redraw(); e.preventDefault(); return;
      }

      // Fresh selection & paint-add by default
      clearSelection();
      addToSelection(hit.r, hit.c);
      state.paintDrag = { adding: true, lastKey: k };
      redraw(); e.preventDefault();
    }

    function onMove(e) {
      if (!state.img) return;

      if (state.mode === 'align') {
        if (!state.drag) return;
        const { x, y } = getPos(e);
        if (state.drag.mode === 'move') {
          state.grid.x = x + state.drag.gx;
          state.grid.y = y + state.drag.gy;
        } else if (state.drag.mode === 'scale') {
          // Desired bottom-right follows the cursor; top-left stays at tlx0,tly0
          const sizeUnit = state.grid.cell * 9;            // size when s = 1
          const newSize  = Math.max( x - state.drag.tlx0,  y - state.drag.tly0 );
          let s = newSize / sizeUnit;

          // clamp like before
          s = Math.max(0.2, Math.min(5, s));
          state.grid.s = s;

          // Recompute center so that top-left remains fixed
          const half = (sizeUnit * s) / 2;
          state.grid.x = state.drag.tlx0 + half;
          state.grid.y = state.drag.tly0 + half;
        }
        redraw(); e.preventDefault(); return;
      }

      if (!state.paintDrag) return;
      const { x, y } = getPos(e);
      const hit = boardHit(x, y);
      if (!hit) return;

      const k = keyOf(hit.r, hit.c);
      if (k === state.paintDrag.lastKey) return;

      if (state.paintDrag.adding) addToSelection(hit.r, hit.c);
      else state.board.selection.delete(k);

      state.paintDrag.lastKey = k;
      redraw(); e.preventDefault();
    }

    function onUp() {
      if (state.mode === 'align' && state.drag) saveGridToCache();
      state.drag = null;
      state.paintDrag = null;
    }


    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    canvas.addEventListener('touchstart', onDown, {passive:false});
    canvas.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp);

    // --------------- UI controls ------------
    confirmBtn.addEventListener('click', () => {
      if (!state.img) return;
      // freeze current grid geometry into board
      const rect = gridRect();
      state.board.x = Math.round(rect.x);
      state.board.y = Math.round(rect.y);
      state.board.cell = rect.cell;

      state.mode = 'solve';
      state.board.selection = new Set();
      state.board.anchor = { r:-1, c:-1 };
      keypad.style.display = 'inline-flex';
      gridTip.style.display = 'none';
      
      saveGridToCache();
      saveToCache();
      redraw();
    });

    // keypad clicks
    keypad.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-n]');
      if (!btn) return;
      commitDigit(+btn.getAttribute('data-n')); // 0 clears
    });

    // digit entry applies to all selected cells
    function commitDigit(d) {
      if (state.mode !== 'solve' || !anySelected()) return;
      pushHistory();
      for (const k of state.board.selection) {
        const [r,c] = k.split(',').map(Number);
        state.board.values[r][c] = d; // 0 clears
        if (d !== 0) {
          state.board.hints.center[r][c].clear();
          state.board.hints.top[r][c].clear();
          state.board.hints.bottom[r][c].clear();
        }
      }
      redraw();
    }

    function clearBox(br, bc) {
      const r0 = br * 3, c0 = bc * 3;
      for (let r = r0; r < r0 + 3; r++) {
        for (let c = c0; c < c0 + 3; c++) {
          state.board.values[r][c] = 0;
          state.board.hints.center[r][c].clear();
          state.board.hints.top[r][c].clear();
          state.board.hints.bottom[r][c].clear();
        }
      }
    }

    function clearSelectedCellsAll() {
      if (!anySelected()) return;
      pushHistory();
      for (const k of state.board.selection) {
        const [r, c] = k.split(',').map(Number);
        state.board.values[r][c] = 0;
        state.board.hints.center[r][c].clear();
        state.board.hints.top[r][c].clear();
        state.board.hints.bottom[r][c].clear();
      }
      redraw();
    }

    // ---- Undo/Redo ----
    const history = { past: [], future: [], limit: 200 };

    function cloneValues(vals) {
      return vals.map(row => row.slice());
    }
    function cloneHintsGrid(grid) {
      return grid.map(row => row.map(set => new Set(set))); // deep copy Sets
    }
    function snapshotBoard() {
      return {
        values: cloneValues(state.board.values),
        hints: {
          center: cloneHintsGrid(state.board.hints.center),
          top:    cloneHintsGrid(state.board.hints.top),
          bottom: cloneHintsGrid(state.board.hints.bottom),
        }
      };
    }
    function restoreBoard(snap) {
      state.board.values = cloneValues(snap.values);
      state.board.hints.center = cloneHintsGrid(snap.hints.center);
      state.board.hints.top    = cloneHintsGrid(snap.hints.top);
      state.board.hints.bottom = cloneHintsGrid(snap.hints.bottom);
      redraw();
    }
    function pushHistory() {
      history.past.push(snapshotBoard());
      if (history.past.length > history.limit) history.past.shift();
      history.future.length = 0;
      saveToCache();
    }
    function undo() {
      if (!history.past.length) return;
      const now = snapshotBoard();
      history.future.push(now);
      const prev = history.past.pop();
      restoreBoard(prev);
    }
    function redo() {
      if (!history.future.length) return;
      history.past.push(snapshotBoard());
      const next = history.future.pop();
      restoreBoard(next);
    }
    function saveToCache() {
      const prev = JSON.parse(localStorage.getItem('sudokuCache') || '{}');
      const snapshot = {
        values: state.board.values, // plain numbers OK
        hints: {
          center: serializeHints(state.board.hints.center),
          top:    serializeHints(state.board.hints.top),
          bottom: serializeHints(state.board.hints.bottom),
        }
      };
      const out = { ...prev, ...snapshot, mode: state.mode };
      localStorage.setItem('sudokuCache', JSON.stringify(out));
    }

    // --------------- Drag & Drop ------------
    const showHint = (b) => dropHint.classList.toggle('show', !!b);
    ['dragenter','dragover'].forEach(t => window.addEventListener(t, (e)=>{ e.preventDefault(); e.dataTransfer&&(e.dataTransfer.dropEffect='copy'); showHint(true); }));
    ['dragleave','drop'].forEach(t => window.addEventListener(t, (e)=>{ e.preventDefault(); if(t==='drop'){ const f=e.dataTransfer&&e.dataTransfer.files; if(f&&f[0]) handleFile(f[0]); } showHint(false); }));

    // --------------- File input -------------
    fileInput.addEventListener('change', (e) => { const f = e.target.files && e.target.files[0]; handleFile(f); e.target.value=''; });

    // --------------- Keyboard ---------------
    state.mod = { zDown: false };
    window.addEventListener('keydown', (e) => {
      if (e.key === 'q' || e.key === 'Q') state.mod.zDown = true;
    });
    window.addEventListener('keyup', (e) => {
      if (e.key === 'q' || e.key === 'Q') state.mod.zDown = false;
    });

    window.addEventListener('keydown', (e) => {
      if (state.mode !== 'solve') return;

      // ---- HINT MODIFIERS ----
      // Map Digit1..Digit9 to 1..9 (works with Shift)
      const digitMatch = /^Digit([1-9])$/;
      const m = digitMatch.exec(e.code);

      // Bottom hints: hold Z + number
      if (state.mod.zDown && m) {
        e.preventDefault();
        commitHint('bottom', +m[1]);
        return;
      }
      // Top hints: Shift + number
      if (e.shiftKey && m) {
        e.preventDefault();
        commitHint('top', +m[1]);
        return;
      }
      // Center hints: Ctrl/Cmd + number
      if ((e.ctrlKey || e.metaKey) && m) {
        e.preventDefault();
        commitHint('center', +m[1]);
        return;
      }

      // --- Clear specific hint rows with Backspace/Delete combos ---
      // Order matters: check Q-hold first, then Cmd/Ctrl, then Shift.

      if ((e.key === 'Backspace' || e.key === 'Delete') && state.mod.zDown) {
        // Q + Backspace → clear BOTTOM hints
        e.preventDefault();
        clearHints('bottom');
        setStatus('Cleared bottom hints in selection.');
        return;
      }

      if ((e.key === 'Backspace' || e.key === 'Delete') && (e.metaKey || e.ctrlKey)) {
        // Cmd/Ctrl + Backspace → clear CENTER hints
        e.preventDefault();
        clearHints('center');
        setStatus('Cleared center hints in selection.');
        return;
      }

      if ((e.key === 'Backspace' || e.key === 'Delete') && e.shiftKey) {
        // Shift + Backspace → clear TOP hints
        e.preventDefault();
        clearHints('top');
        setStatus('Cleared top hints in selection.');
        return;
      }

      // Clear ONLY the selected cells (value + all hints)
      if ((e.key === 'Backspace' || e.key === 'Delete')
          && !e.shiftKey && !e.ctrlKey && !e.metaKey && !state.mod.zDown) {
        e.preventDefault();
        clearSelectedCellsAll();
        return;
      }

      // Undo / Redo
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
        e.preventDefault();
        undo();
        return;
      }
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && (e.key === 'z' || e.key === 'Z')))) {
        e.preventDefault();
        redo();
        return;
      }

      // digits
      if (/^[1-9]$/.test(e.key)) { commitDigit(+e.key); return; }
      if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') { commitDigit(0); return; }

      // arrows: move anchor or extend with Shift
      const dir = { ArrowUp:[-1,0], ArrowDown:[1,0], ArrowLeft:[0,-1], ArrowRight:[0,1] }[e.key];
      if (!dir) return;

      // if nothing selected, start at (0,0)
      if (!anySelected()) {
        state.board.anchor = { r:0, c:0 };
        clearSelection(); addToSelection(0,0);
        redraw(); return;
      }

      const a = state.board.anchor.r >= 0 ? state.board.anchor : firstSelected();
      let nr = Math.max(0, Math.min(8, a.r + dir[0]));
      let nc = Math.max(0, Math.min(8, a.c + dir[1]));

      if (e.shiftKey) {
        selectRange(a.r, a.c, nr, nc);
      } else {
        state.board.anchor = { r:nr, c:nc };
        clearSelection(); addToSelection(nr, nc);
      }
      redraw();
    });

    function getImageRect() {
      if (!state.img) return null;
      return fitImageRect(
        state.imgNaturalW, state.imgNaturalH,
        canvas.clientWidth, canvas.clientHeight
      );
    }

    function saveGridToCache() {
      if (!state.img) return;
      const rect = getImageRect();
      if (!rect) return;

      // compute top-left of grid in canvas space
      const size = state.grid.cell * 9 * state.grid.s;
      const half = size / 2;
      const tlx = state.grid.x - half;
      const tly = state.grid.y - half;

      // store as ratios so it survives different viewport sizes
      const gridRel = {
        tlx: (tlx - rect.x) / rect.w,  // 0..1 from image-left
        tly: (tly - rect.y) / rect.h,  // 0..1 from image-top
        sizeW: size / rect.w           // grid size relative to image width
      };

      const cached = JSON.parse(localStorage.getItem('sudokuCache') || '{}');
      cached.gridRel = gridRel;
      cached.mode = state.mode;
      localStorage.setItem('sudokuCache', JSON.stringify(cached));
    }

    function restoreGridFromCacheIfAny(cache) {
      if (!cache || !cache.gridRel || !state.img) return;
      const rect = getImageRect();
      if (!rect) return;

      const size = cache.gridRel.sizeW * rect.w;
      // keep your existing base cell; derive scale from desired size
      state.grid.s = Math.max(0.2, Math.min(5, size / (state.grid.cell * 9)));

      const half = (state.grid.cell * 9 * state.grid.s) / 2;
      const tlx = rect.x + cache.gridRel.tlx * rect.w;
      const tly = rect.y + cache.gridRel.tly * rect.h;

      state.grid.x = tlx + half;
      state.grid.y = tly + half;
      state.grid._initialized = true; // we've placed it explicitly
    }

    function serializeHints(h) {
      return h.map(row => row.map(s => Array.from(s))); // Set -> array
    }
    function deserializeHints(h) {
      return h.map(row => row.map(arr => new Set(arr || []))); // array -> Set
    }

    function canvasToBlob() {
      return new Promise((resolve) => {
        resizeCanvasToDisplaySize();
        redraw();
        canvas.toBlob((blob) => resolve(blob), 'image/png');
      });
    }

    function clearAllBoard() {
      if (!state.img) { setStatus('Nothing to clear yet.'); return; }

      // Only meaningful in solve mode; in align mode there’s nothing to clear.
      if (state.mode !== 'solve') { setStatus('Switch to Solve to clear.'); return; }

      pushHistory();

      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          state.board.values[r][c] = 0;
          state.board.hints.center[r][c].clear();
          state.board.hints.top[r][c].clear();
          state.board.hints.bottom[r][c].clear();
        }
      }

      state.board.selection.clear();
      state.board.anchor = { r:-1, c:-1 };

      saveToCache();
      redraw();
      setStatus('Cleared all digits and hints.');
    }

    clearAllBtn.addEventListener('click', clearAllBoard);

    async function saveCanvasAs() {
      if (!state.img) { setStatus('Nothing to save yet.'); return; }
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      const suggestedName = `sudoku-overlay-${ts}.png`;
      const blob = await canvasToBlob();
      if (!blob) return;

      // Preferred: File System Access API (Chrome/Edge, some Opera/Android)
      if (window.showSaveFilePicker) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName,
            types: [{
              description: 'PNG Image',
              accept: { 'image/png': ['.png'] }
            }]
          });
          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();
          setStatus('Saved. (Picked name & location.)');
          return;
        } catch (err) {
          if (err && err.name === 'AbortError') { setStatus('Save canceled.'); return; }
          console.error(err);
          // fall through to legacy download
        }
      }

      // Fallback: regular download (browser may auto-save to Downloads)
      const a = document.createElement('a');
      a.download = suggestedName;            // suggested file name
      a.href = URL.createObjectURL(blob);
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
      setStatus('Downloaded. (File name/location depend on browser settings.)');
    }

    saveBtn.addEventListener('click', saveCanvasAs);

    // --------------- Resize -----------------
    const ro = new ResizeObserver(() => redraw());
    ro.observe(document.body);
    window.addEventListener('orientationchange', () => setTimeout(redraw, 100));

    // First paint
    redraw();

    (function loadFromCache() {
      const raw = localStorage.getItem('sudokuCache');
      const imgData = localStorage.getItem('sudokuImage');
      if (!raw && !imgData) return;

      const cache = raw ? JSON.parse(raw) : null;

      // Restore board first (even if image missing)
      if (cache) {
        if (cache.values) state.board.values = cloneValues(cache.values);
        if (cache.hints) {
          state.board.hints.center = deserializeHints(cache.hints.center);
          state.board.hints.top    = deserializeHints(cache.hints.top);
          state.board.hints.bottom = deserializeHints(cache.hints.bottom);
        }
        state.mode = cache.mode === 'align' ? 'align' : 'solve';
        state.board.selection = new Set();
        state.board.anchor = { r:-1, c:-1 };
        if (state.mode === 'solve') { keypad.style.display = 'inline-flex'; gridTip.style.display = 'none'; }
        else { keypad.style.display = 'none'; gridTip.style.display = ''; }
      }

      // Restore image, then restore grid (needs image rect)
      if (imgData) {
        const img = new Image();
        img.onload = () => {
          state.img = img;
          state.imgNaturalW = img.naturalWidth;
          state.imgNaturalH = img.naturalHeight;
          if (cache) restoreGridFromCacheIfAny(cache); // ← now rect exists
          redraw();
          setStatus('Restored cached puzzle');
        };
        img.src = imgData;
      } else {
        redraw(); // board-only restore
      }
    })();

  </script>
</body>
</html>
